import { invoke } from "@tauri-apps/api/core";
import { fetch } from "@tauri-apps/plugin-http";
import { getRecord, insertRecord } from "./stronghold";

export class LastFM {
    /**
     * Represents a LastFM API client.
     * @param {Object} options - The options for the LastFM client.
     * @param {string} options.apiKey - The API key for LastFM.
     * @param {string} options.apiSecret - The API secret for LastFM.
     * @param {string} [options.apiUrl='http://ws.audioscrobbler.com/2.0/'] - The API URL for LastFM.
     * @constructor
     */
    constructor(options) {
        this.apiKey = options.apiKey;
        this.apiSecret = options.apiSecret;
        this.apiUrl = options.apiUrl;
        this.album = new Album(this);
        this.artist = new Artist(this);
        this.auth = new Auth(this);
    }

    /**
     * Make a request to the LastFM API.
     * @param {string} endpoint - The endpoint to request.
     * @param {Object} params - The parameters to send with the request.
     * @param {string} [method='GET'] - The HTTP method to use.
     * @returns {Promise<Object>}
     */
    async request(endpoint, params, method = 'GET') {
        let url = this.apiUrl + '?method=' + endpoint + '&api_key=' + this.apiKey + '&format=json';
    
        for (let key in params) {
            if (key == null) continue;
            url += '&' + key + '=' + encodeURIComponent(params[key]);
        }
    
        if (method === 'POST') {
            return fetch(url, { method: method, body: JSON.stringify(params) })
                .then(res => res.json())
                .then(data => {
                    return data;
                });
        }
    
        return fetch(url)
            .then(res => res.json())
            .then(data => {
                return data;
            });
    }

    /**
     * Make a signed request to the LastFM API.
     * @param {string} endpoint - The endpoint to request.
     * @param {Object} params - The parameters to send with the request.
     * @param {string} sk - A session key generated by authenticating a user via the authentication protocol.
     * @param {string} [method='GET'] - The HTTP method to use.
     * @returns {Promise<Object>}
     */
    async requestSigned(endpoint, params, sk, method = 'GET') {
        let signature = md5(`api_key${this.apiKey}method${endpoint}${params}${this.apiSecret}`);

        return this.request(endpoint, { ...params, api_sig: signature, sk }, method);
    }
}

class Album {
    #client;

    /**
     * Represents the Album API for LastFM.
     * @param {LastFM} client - The LastFM client.
     * @constructor
     */
    constructor(client) {
        this.#client = client;
    }

    /**
     * Tag an album using a list of user supplied tags.
     * @param {Object} params
     * @param {string} params.artist - The artist name.
     * @param {string} params.album - The album name. 
     * @param {string} params.tags - A comma delimited list of user supplied tags to apply to this album. Accepts a maximum of 10 tags.
     * @param {string} sk - A session key generated by authenticating a user via the authentication protocol.
     * @returns {Promise<Object>}
     * @see {@link https://www.last.fm/api/show/album.addTags}
     */
    async addTags(params, sk) {
        return this.#client.requestSigned('album.addtags', params, sk, 'POST');
    }

    /**
     * Get the metadata and tracklist for an album on Last.fm using the album name or a musicbrainz id.
     * @param {Object} params
     * @param {string} params.artist - The artist name.
     * @param {string} params.album - The album name.
     * @param {string} [params.mbid] - The musicbrainz id for the album.
     * @param {string} [params.autocorrect] - Transform misspelled artist names into correct artist names, returning the correct version instead. The corrected artist name will be returned in the response.
     * @returns {Promise<Object>}
     * @see {@link https://www.last.fm/api/show/artist.getInfo}
     */
    async getInfo(params) {
        return this.#client.request('album.getinfo', params);
    }
}

class Artist {
    #client;

    /**
     * Represents the Artist API for LastFM.
     * @param {LastFM} client - The LastFM client.
     * @constructor
     */
    constructor(client) {
        this.#client = client;
    }

    async getCorrection(params) {
        return this.#client.request('artist.getcorrection', params);
    }

    /**
     * Get the metadata for an artist. Includes biography, truncated at 300 characters.
     * @param {Object} params
     * @param {string} params.artist - The artist name.
     * @param {string} [params.mbid] - The musicbrainz id for the artist.
     * @param {string} [params.lang] - The language to return the biography in, expressed as an ISO 639 alpha-2 code.
     * @param {0|1} [params.autocorrect=1] - Transform misspelled artist names into correct artist names, returning the correct version instead. The corrected artist name will be returned in the response.
     * @param {string} [params.username] - The username for the context of the request. If supplied, the user's playcount for this artist is included in the response.
     * @returns {Promise<Object>}
     * @see {@link https://www.last.fm/api/show/artist.getInfo}
     */
    async getInfo(params) {
        return this.#client.request('artist.getinfo', params);
    }

    async getSimilar(params) {
        return this.#client.request('artist.getsimilar', params);
    }

    async getTags(params) {
        return this.#client.request('artist.gettags', params);
    }

    async getTopAlbums(params) {
        return this.#client.request('artist.gettopalbums', params);
    }

    async getTopTags(params) {
        return this.#client.request('artist.gettoptags', params);
    }

    async getTopTracks(params) {
        return this.#client.request('artist.gettoptracks', params);
    }

    async removeTag(params, sk) {
        // return this.#client.requestSigned('artist.removetag', params, sk, 'POST');
    }

    async search(params) {
        return this.#client.request('artist.search', params);
    }
}

class Auth {
    #client;

    /**
     * Represents the Auth API for LastFM.
     * @param {LastFM} client - The LastFM client.
     * @constructor
     */
    constructor(client) {
        this.#client = client;
    }

    /**
     * 
     * @param {Object} params 
     * @param {string} params.token - A 32-character ASCII hexadecimal MD5 hash returned by step 1 of the authentication process (following the granting of permissions to the application by the user)
     * @param {string} params.api_key - A Last.fm API key.
     * @param {string} params.api_sig - A Last.fm method signature. See {@link https://www.last.fm/api/authentication} for more information.
     * @returns {Promise<Object>}
     */
    async getSession(params) {
        return this.#client.request('auth.getSession', params);
    }

    /**
     * 
     * @param {Object} params
     * @param {string} params.api_key - A Last.fm API key.
     * @param {string} params.api_sig - A Last.fm method signature. See {@link https://www.last.fm/api/authentication} for more information.
     * @returns {Promise<Object>}
     */
    async getToken(params) {
        return this.#client.request('auth.getToken', params);
    }
}

export const lastFm = new LastFM({
    apiKey: import.meta.env.VITE_LASTFM_API_KEY,
    apiSecret: import.meta.env.VITE_LASTFM_SECRET
});

// export function getSession(token) {
//     return getRecord("lastfm_session")
//         .then(session => {
//             if (session) {
//                 return session;
//             }

//             let signature = md5(`api_key${ApiCredentials.apiKey}methodauth.getSessiontoken${token}${ApiCredentials.secret}`);
//             console.log(signature);

//             return fetch(`https://ws.audioscrobbler.com/2.0/?method=auth.getsession&token=${token}&api_key=${ApiCredentials.apiKey}&api_sig=${signature}&format=json`)
//                 .then(res => res.json())
//                 .then(data => {
//                     console.log(data);
//                     insertRecord("lastfm_session", data.session);
//                     return data.session;
//                 });
//         })
//         .catch(err => {
//             console.error(err);
//         });
// }

async function download(url, dest) {
    const response = await fetch(url);

    await invoke("write_file", { path: dest, contents: response.json() });
}

async function getArtistImageLastFm(artist) {
    if (!artist || !artist.url) return null;
    
    let lastFmImage = fetch(artist.url)
        .then(res => {
            return res.text();
        }).then(data => {
            let parser = new DOMParser();
            let doc = parser.parseFromString(data, 'text/html');
            let images = doc.querySelectorAll('.image-list-item');
            if (images.length === 0) {
                return null;
            }
            let img = images[0].querySelector('img');

            if (!img || !img.src) {
                return null;
            }

            return img.src;
        });

    if (lastFmImage) {
        return lastFmImage;
    }

    return getArtistImageDeezer(artist);
}

async function getArtistImageDeezer(artist) {
    return fetch(`https://api.deezer.com/search/artist?q="${artist.name}"&limit=1&strict=on`)
        .then(res => {
            return res.json();
        })
        .then(data => {
            return data.data[0].picture_xl;
        });
}

export async function getArtistImage(name) {
    let artistInfo = await lastFm.artist.getInfo({ artist: name });

    return artistInfo.thumbnail;

}

export async function getAlbumId(title, artist) {
    return fetch(`https://api.deezer.com/search/album?q=artist:"${artist}" album:"${title}"&limit=1`)
        .then(res => res.json())
        .then(data => {
            return data.data[0].id;
        });
}

export async function getAlbumDeezer(id) {
    return fetch(`https://api.deezer.com/album/${id}`)
        .then(res => res.json())
        .then(data => {
            return data;
        });
}

export async function getAlbumImage(title, artist) {
    let albumId = await getAlbumId(title, artist);
    let album = await getAlbumDeezer(albumId);

    return album.cover_xl;
}

export async function downloadCoverImage(album) {
    let albumImage = await getAlbumImage(album.title, album.artist);
    let dest = album.location_on_disk + "/Cover.jpg";

    await download(albumImage, dest);
}